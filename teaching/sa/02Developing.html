<!doctype html>
<html lang="zh_TW">

<head>
<meta charset="utf-8">

<title>資訊開發模式</title>

<meta name="description" content="Management Information System">
<meta name="author" content="Elvis Hsieh">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="/reveal-js/css/reveal.min.css">
<link rel="stylesheet" href="/reveal-js/css/theme/black.min.css" id="theme">
<link rel="stylesheet" href="/css/custom4revealjs.css">
<!-- Code syntax highlighting -->
<link rel="stylesheet" href="/reveal-js/lib/css/zenburn.css">
<link rel="stylesheet" href="/highlight-js/styles/default.min.css">  
<link rel="stylesheet" href="/css/style4font.css">
<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /reveal-js/print-pdf/gi ) ? '/reveal-js/css/print/pdf.css' : '/reveal-js/css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<!--[if lt IE 9]>
<script src="reveal-js/lib/js/html5shiv.js"></script>
<![endif]-->

</head>

<body>

<div class="reveal">

<!-- 每一個 section element inside of this container is displayed as a slide -->
<div class="slides">
<section data-markdown><script type="text/template">
# System Development
</script>
</section>

<section data-markdown><script type="text/template">
##  The phases of 
## System Development Life Cycle
<ul>
    <li class="fragment">系統規劃 (System Planning Phase)</li>
    <li class="fragment">系統分析 (System Analysis Phase)</li>
    <li class="fragment">系統設計 (System Design Phase)</li>
    <li class="fragment">系統實作 (System Implemment Phase)</li>
    <li class="fragment">系統支持與安全性 (System Support and Security Phase)</li>
</ul>
</script>
</section>
<section>
        <h2>System Development Process</h2>
        <ul>
            <li class="fragment">需求分析：了解現行作業內容、蒐集資料</li>
            <li class="fragment">可行方案：是否可行？</li>
            <li class="fragment">分析與設計：決定電腦化系統的架構與功能</li>
            <li class="fragment">開發：軟體設計, 程式寫作及測試</li>
            <li class="fragment">建構：導入新系統, 最好與舊系統並行</li>
            <li class="fragment">維護：維持運作, 提高效能、因應改變</li>
        </ul>
    </section>
    <section>
            <h2>People in SDLC</h2>
            <ul>
                <li class="fragment">需要不同的專業人員：</li>
                <ul>
                    <li class="fragment">系統分析師：負責開發週期前三個階段的專業人員, 需要熟悉資訊科技與企業管理的實際作業</li>
                    <li class="fragment">程式設計師：撰寫程式</li>
                    <li class="fragment">專案經理：管理整個資訊系統建立的過程</li>
                </ul>
                <li class="fragment">特色：每階段工作完成後的產品是文件, 如需求分析書</li>
            </ul>
    </section>
    <section>
    <section>
        <h2>資訊系統開發的挑戰</h2>
        <ul>
            <li class="fragment">快速上線的緊縮時程</li>
            <li class="fragment">多媒體展現</li>
            <li class="fragment">大量客製化</li>
            <li class="fragment">支援多國語言</li>
            <li class="fragment">大規模佈署</li>
            <li class="fragment">日益增加的系統複雜度及高度整合要求</li>
        </ul>
        <hr class="fragment">
        <ul>
            <li class="fragment">因此, 需要團隊運作的系統化開發流程</li>
        </ul>
    </section>


    <section>
        <h1>資訊系統的開發的策略</h1>
        <ul>
            <li class="fragment">套裝軟體 (Application Software Packages)</li>
            <li class="fragment">終端使用者自行開發 (End-user Development)</li>
            <li class="fragment">外包 (Outsourcing)</li>
        </ul>
    </section>

    <section>
    <h2>Packages &amp; End-user Development</h2>
    <ul>
        <li class="fragment">套裝軟體 (Application Software Packages)</li>
        <ul>
            <li class="fragment">已撰寫好的應用軟體, 再進行客製化的修改</li>
            <li class="fragment">成本較低, 開發時間也較短</li>
            <li class="fragment">較不符合使用者的所有需求</li>
            <li class="fragment">終端使用者自行開發</li>
        </ul>
        <li class="fragment">End-user Development</li>
        <ul>
            <li class="fragment">利用功能強大的軟體自行開發符合自己需求的系統, 如利用試算表軟體</li>
            <li class="fragment">凌亂不易整合, 企業較不鼓勵</li>
        </ul>
    </ul>
    </section>
    <section data-markdown><script type="text/template">
## 外包 (Outsourcing)
<ul>
    <li class="fragment">委外專業軟體開發公司提供服務</li>
    <li class="fragment">租用式的資訊系統, 公用計費的概念</li>
    <li class="fragment">缺點：</li>
    <ul>
        <li class="fragment">監督廠商的花費</li>
        <li class="fragment">廠商溝通困難</li>
        <li class="fragment">受制於人</li>
        <li class="fragment">商業機密可能外洩</li>
        <li class="fragment">不易創造競爭優勢</li>
    </ul>
    <li class="fragment">適用於非策略性的資訊系統</li>
</ul>
    </script>
    </section>
    </section>
    <section>
    <section>
        <h2>資訊系統開發的概念與技術 (1/5)</h2>
        <ul>
            <li class="fragment">1970 年代：強調「結構化程式設計」、「專案管理」和「資料庫管理系統」</li>
            <li class="fragment">結構化程式設計的四點特色：</li>
            <li class="fragment">採用資料流程圖 (DFD) 描述「資料」與「處理」間的關係</li>
            <li class="fragment">採用資料辭典, 正式定義資料</li>
            <li class="fragment">採用工具以描述「處理邏輯」, 如結構化英文、決策表、決策樹及虛擬碼等</li>
            <li class="fragment">用結構圖定義程式模組</li>
        </ul>
    </section>
    <section>
        <h2>資訊系統開發的概念與技術 (2/5)</h2>
        <ul>
            <li class="fragment">結構化程式設計的好處：</li>
            <ul>
                <li class="fragment">增進規律性：建立標準的處理方式和文件, 消除個人風格, 以達到一定的品質</li>
                <li class="fragment">可信度和錯誤校正：使用標準的方法和工具可即早發現疏失或錯誤, 予以修正</li>
                <li class="fragment">有效運用資源：此方法可節省成本、提升生產力及較佳的人力資源分派</li>
            </ul>
            <li class="fragment">1980年代：第四代語言 (4GL)</li>
            <ul>
                <li class="fragment">僅告訴電腦「做什麼」, 如 SQL、試算表軟體等</li>
                <li class="fragment">雛型系統設計和終端使用者自行開發</li>
                <li class="fragment">電腦輔助軟體工具, 需嚴格遵守一套軟體發展程序</li>
                <li class="fragment">軟體再使用性, 造成「物件導向」技術的躍進</li>
            </ul>
        </ul>
    </section>
    <section>
        <h2>資訊系統開發的概念與技術 (3/5)</h2>
        <ul>
            <li class="fragment">1990 年代：物件導向技術</li>
            <li class="fragment">物件導向技術：系統是一些物件的組合, 再透過物件間訊息傳遞來決定系統的行為, 而每個物件擁有自己的資料儲存空間及方式, 並提供一組介面以供外界呼叫</li>
            <li class="fragment">物件導向流行的原因：</li>
            <ul>
                <li class="fragment">電腦應用領域的變化：系統大都屬資料為主的應用, 越來越複雜的資料型態及操作環境, 使得傳統的程序導向的設計, 會使得模組間變得更複雜不易掌握</li>
                <li class="fragment">軟體工程上的問題：傳統開發的方法, 造成程序模組不具有可再用性, 造成工程師的負擔</li>
            </ul>
        </ul>
    </section>
    <section>
        <h2>資訊系統開發的概念與技術 (4/5)</h2>
        <ul>
            <li class="fragment">1990 年代：網際網路應用系統之開發工具</li>
                <ul>
                    <li class="fragment">建立動態網頁的技術 (如 HTML、DHTML)</li>
                    <li class="fragment">Web伺服器上執行的應用程式 (VBScript、JavaScript)</li>
                    <li class="fragment">安全協定、電子付款等技術</li>
                </ul>
                <li class="fragment">1990 年代：強調快速的資訊系統開發方法</li>
                <ul>
                    <li class="fragment">聯合應用系統開發方法 (JAD)：以使用者為主導, 以管理者為核心, 再由資訊人員輔導的群體系統開發方法</li>
                </ul>
        </ul>
    </section>
    <section>
        <h2>資訊系統開發的概念與技術 (5/5)</h2>
        <ul>
            <li class="fragment">1990 年代：大型整合應用系統：</li>
                <ul>
                    <li class="fragment">整合型套裝軟體的興起, 如 ERP、SCM 與 CRM 等模組的整合</li>
                    <li class="fragment">企業選擇適合的模組整合, 再加上部份外掛模組即可</li>
                </ul>
                <li class="fragment">1990年代：微型應用程式</li>
                <ul>
                    <li class="fragment">APP (Application)：泛指電腦內、或智慧型手機內的應用程式</li>
                    <li class="fragment">以手機四大作業系統為銷售平台： Apple 的 iOS、Google 的 Android、微軟的 Windows Mobile 以及 RIM 的黑莓機等</li>
                </ul>
        </ul>
    </section>
    </section>
    <section>
    <section>
        <h2>行業別系統開發的流程</h2>
            <ol>
                <li class="fragment">蒐集行業電子化需求：<a href="#/4/1"><span>&#8618;</span> Next Slide </a></li>
                <li class="fragment">系統分析：找出可開發的行業後, 由資深顧問師主導系統分析、擬定系統架構、確求行業需求重點</li>
                <li class="fragment">系統設計：根據前述為基礎, 撰寫規格, 而後交付審查, 複審無誤後納入系統版號管控</li>
                <li class="fragment">程式撰寫：撰寫程式後, 進行單元測試, 再交付審查測試</li>
                <li class="fragment">系統測試：經測試後, 須制定整合測試文件, 進行內部的整合測試, 也可請客戶試用測試</li>
                <li class="fragment">撰寫手冊：系統操作手冊的撰寫</li>
                <li class="fragment">產品包裝： 包括程式包裝、系統作業環境、資料庫安裝、更新整合測試等等</li>
            </ol>
    </section>
    <section>
        <h2>蒐集行業電子化需求</h2>
        <ul>
            <li class="fragment">行業客群定義與蒐集：定義出目標行業, 挑選可行性的行業, 再進行名單的蒐集, 可從公會會員名單, 或網站名單蒐集</li>
            <li class="fragment">需求蒐集人員：具系統開發與產業輔導經驗豐富的資深顧問師</li>
            <li class="fragment">需求訪談對象：名單電訪、公會訪談及業者訪談</li>
        </ul>
        <p class="fragment" style="text-align: right"><a href="#/4">Back <span>&#8617;</span></a></p>
    </section>
    </section>
<section>
<section data-markdown><script type="text/template">
# 系統開發模式
</script>
</section>
<section data-markdown><script type="text/template">
## 瀑布模型 (Waterfall Model)
- 強調系統開發應有完整之週期, 且必須完整的經歷週期之每一開發階段, 
並系統化的考量分析與設計的技術、時間與資源之投入等, 因此瀑布模型又可以稱為『系統發展生命週期』(System Development Life Cycle,  SDLC)

- 瀑布模型將軟體生命週期劃分的階段
    * 制定計劃
    * 需求分析
    * 軟體設計
    * 程式編寫
    * 軟體測試與運行
</script>
</section>
<section data-markdown><script type="text/template">
## 瀑布模式的優缺點
- 優點
    * 由於各階段劃分清楚, 因此, 為各項目提供了的檢查點
    * 完成目前階段後, 只需要去關注後續階段
    * 可以在漸增模式中應用瀑布模式

- 缺點
    * 在項目各個階段之間極少有回饋
    * 只有在項目生命週期的後期才能看到結果
    * 通過較多的強制完成日期及里程碑, 來追蹤各個項目階段
</script>
</section>
<section data-markdown><script type="text/template">
## 雛型 (Prototype Model)
<ul>
    <li class="fragment">又稱原型, 是漸增模型的另一種形式</li>
    <li class="fragment">快速的發展出實驗性系統, 以便使用者能加以評估及後續改善的進行；資訊系統的測試版</li>
    <li class="fragment">雛型發展 (Prototyping) 四個步驟：</li>
    <ul>
        <li class="fragment">瞭解使用者需求：獲得基本資訊後, 便開發雛型</li>
        <li class="fragment">開發雛型：快速開發一雛型系統, 僅具備主要功能</li>
        <li class="fragment">使用雛型系統：瞭解是否適用及提出改善</li>
        <li class="fragment">修改與加強雛型：修正系統及測試系統</li>
    </ul>
    <li class="fragment">可較高的使用者滿意度, 尤其是使用者介面, 但不適用於大型系統的開發</li>
</ul>
</script>
</section>
<section data-markdown><script type="text/template">
## 漸增模式 (Incremental Model)
<ul>
    <li class="fragment">漸增模式融合了瀑布模式重複應用的基本成分和原型實現的疊代特徵</li>
    <li class="fragment">漸增模式把需求分成「幾」個部分, 然後依漸增開發計畫將每個「部分需求」之開發訂為一個開發週期, 每個週期可依序或平行開發</li>
    <li class="fragment">每個週期之階段清楚定義要做哪些工作及交付哪些文件, 每個階段循序進行且僅循環一次</li>
    <li class="fragment">第 1 個增量往往是核心的產品, 即第 1 個增量實現基本的需求</li>
    <li class="fragment">客戶對於每一個增量的使用與評估, 都作為下一個增量發布的新特徵和功能</li>
    <li class="fragment">在每一個增量發布後不斷重複, 直到產生了最終完善的產品 (課本圖 p.13)</li>
</ul>
</script>
</section>
<section data-markdown><script type="text/template">
## 螺旋模式 (Spiral Model)
<ul>
    <li class="fragment">螺旋模式結合瀑布模式與雛型模式, 強調其他模式忽略的風險分析</li>
    <li class="fragment">早期就能夠為客戶實證某些概念, 此為雛型模式, 在每個項目階段使用瀑布模式</li>
    <li class="fragment">每一個週期都包括需求定義、風險分析、工程實現與使用者評估四個階段</li>
    <li class="fragment">軟體開發過程每疊代一次, 軟體開發又前進一個層次 (課本圖 p.15)</li>
</ul>
</script>
</section>
<section data-markdown><script type="text/template">
## 螺旋模式的做法與特色
<ul>
    <li class="fragement">螺旋模式基本做法</li>
    <ul>
        <li class="fragment">在瀑布模式的每一個開發階段前, 引入一個非常嚴格的風險辨識、風險分析與風險控管</li>
        <li class="fragment">把每一個軟體分解成一個個小項目, 每一個小項目都標示一個或多個主要風險, 直到所有的主要風險因素都被確定</li>
    </ul>
<li class="fragment">螺旋模式之特色與應用原則</li>
    <ul>
        <li class="fragment">在高風險部分之設計尚未穩定前, 規格之發展不需要一致、詳盡或正式, 以避免不必要之設計修改</li>
        <li class="fragment">在開發之任一階段, 螺旋模式可選擇整合雛型模式以低風險</li>
        <li class="fragment">當更吸引人之方案被找出或新風險需被解決時, 螺旋模式整合重做或回到前面之階段</li>
    </ul>
</ul> 
</script>
</section>
<section data-markdown><script type="text/template">
## 同步模式 (Concurrent Model,  1/2)
<ul>
    <li class="fragment">同步模式源自於製造業的同步工程, 其目的在於縮短系統開發時間, 以加速版本之更新</li>
    <li class="fragment">基於三個主要的構想來達到時程縮短的目標</li>
    <ul>
        <li class="fragment">多個團隊同時開發：多組人同時工作的方式稱為活動同步</li>
        <li class="fragment">資訊同步：不同團隊的資訊互相交流與共享, 稱為資訊同步</li>
        <li class="fragment">整合性的管理系統：同步模式的管理比一般的開發模式複雜, 必須開發一個管理系統以協調人員、資源、過程及產品間複雜的互動關係</li>
    </ul>
 
</ul>
</script>
</section>
<section data-markdown><script type="text/template">
## 同步模式 (Concurrent Model,  2/2)
<ul>
    <li class="fragment">資訊同步有三個技巧：</li>
        <ul>
            <li class="fragment">向前傳遞 (Front Loading): 將後階段重要議題與考慮因素, 提前讓前階段的開發團隊知道</li>
            <li class="fragment">向後傳遞 (Flying)： 將前階段開發情況以及重要的資訊, 傳遞給後階段的開發團隊</li>
            <li class="fragment">建立有效的資訊交換網路及群體工作的支援環境</li>
        </ul>
    <li class="fragment">同步模式的發展主要是為了因應商業套裝軟體的市場競爭</li>
    <li class="fragment">同步模式的優缺點</li>
        <ul>
            <li class="fragment">優點是開發時間的縮短可提高產品的競爭力</li>
            <li class="fragment">其缺點則是緊湊的步驟及頻繁的資訊溝通, 使得專案管理的複雜度大幅提高, 人力成本也相對提高</li>
            <li class="fragment">沒有輔以良好的工具及管理方法, 則不易達成目標</li>
        </ul>
</ul>
</script>
</section>
<section data-markdown><script type="text/template">
## 統一軟體開發過程 (RUP)
<ul>
    <li class="fragment">統一軟體開發過程 (Rational Unified Process,  RUP) 模式於 1998 年由 Jacobson 等人提出</li>
    <li class="fragment">統一軟體開發過程又稱為統一軟體過程, 為疊代式軟體開發流程</li>
    <li class="fragment">該模式結合螺旋模式的概念, 以反覆與漸增的軟體發展原理進行軟體開發, 且每一次的反覆需產出一個可運作的系統版本, 並在每一個反覆週期評估風險, 以盡早發現問題</li>
    <li class="fragment">RUP模式可由動態與靜態兩個構面來說明系統開發專案之實施階段與核心工作</li>
 </ul>
</script>
</section>
<section data-markdown><script type="text/template">
## 統一軟體過程九個核心工作流程(1/2)
<ul>
    <li class="fragment">商業建模 (Business Modeling)：商業建模工作流程是描述如何為新的目標組織開發一個構想, 並基於這個構想, 
        在商業範圍模型和商業對象模型中, 定義組織的過程、角色和責任</li>
    <li class="fragment">需求 (Requirements)：需求的工作流程的目標是描述系統應該做些什麼, 並使開發人員和使用者就這一描述達成共識</li>
    <li class="fragment">分析與設計 (Analysis and Design)：分析與設計工作流程將需求轉化成未來系統的設計, 是一個設計模型和一個可選擇的分析模型</li>
    <li class="fragment">實作 (Implementation)：實作工作流程的目的是以組件的形式(原始檔、二進制檔、可執行檔)實作出整合對象, 將開發出來的元件, 進行測試, 以整合開發產生的結果, 使成為可執行的系統</li>
</ul>
</script>
</section>
<section data-markdown><script type="text/template">
## 統一軟體過程九個核心工作流程(2/2)
<ul>
    <li class="fragment">測試 (Test)：測試工作流程要驗證對象間的交互作用, 驗證軟體中所有組件的正確性, 驗證所有需求已經被正確實現, 識別並確認缺陷在軟體部署之前被提出並處理</li>
    <li class="fragment">部署 (Deployment)：部署工作流程目的是成功地生成版本, 並將軟體分發給最終的使用者</li>
    <li class="fragment">配置和變動管理(Configuration & Change Management)：配置和變動管理工作流程描繪了如何在多個成員組織的項目中, 控制大量的產物</li>
    <li class="fragment">專案管理 (Project Management)：軟體的專案管理平衡各種可能產生的衝突的目標、管理風險, 克服各種約束並成功地交付使用戶滿已的產品</li>
    <li class="fragment">環境 (Environment)：是向軟體開發組織提供軟體開發環境, 包括過程和工具</li>
</ul>
</script>
</section>

</section>
    </div>
</div>


<script src="/reveal-js/lib/js/head.min.js"></script>
<script src="/reveal-js/js/reveal.min.js"></script>

<script>

// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
controls: false,
progress: true,
history: false,
center: true,
slideNumber: true,

transition: 'slide', // none/fade/slide/convex/concave/zoom

	menu: {
		// Specifies which side of the presentation the menu will 
		// be shown. Use 'left' or 'right'.
		side: 'left',

		// Specifies the width of the menu.
		// Can be one of the following:
		// 'normal', 'wide', 'third', 'half', 'full', or
		// any valid css length value
		width: 'normal',

		// Add slide numbers to the titles in the slide list.
		// Use 'true' or format string (same as reveal.js slide numbers)
		numbers: false,

		// Specifies which slide elements will be used for generating
		// the slide titles in the menu. The default selects the first
		// heading element found in the slide, but you can specify any
		// valid css selector and the text from the first matching
		// element will be used.
		// Note: that a section data-menu-title attribute or an element
		// with a menu-title class will take precedence over this option
		titleSelector: 'h1, h2, h3, h4, h5, h6',

		// If slides do not have a matching title, attempt to use the
		// start of the text content as the title instead
		useTextContentForMissingTitles: false,

		// Hide slides from the menu that do not have a title.
		// Set to 'true' to only list slides with titles.
		hideMissingTitles: false,

		// Adds markers to the slide titles to indicate the 
		// progress through the presentation. Set to 'false'
		// to hide the markers.
		markers: true,

		// Specify custom panels to be included in the menu, by
		// providing an array of objects with 'title', 'icon'
		// properties, and either a 'src' or 'content' property.
		custom: true,

		// Specifies the themes that will be available in the themes
		// menu panel. Set to 'true' to show the themes menu panel
		// with the default themes list. Alternatively, provide an
		// array to specify the themes to make available in the
		// themes menu panel, for example...
		// [
		//     { name: 'Black', theme: 'css/theme/black.css' },
		//     { name: 'White', theme: 'css/theme/white.css' },
		//     { name: 'League', theme: 'css/theme/league.css' }
		// ]
		themes: true,

		// Specifies the path to the default theme files. If your
		// presentation uses a different path to the standard reveal
		// layout then you need to provide this option, but only
		// when 'themes' is set to 'true'. If you provide your own 
		// list of themes or 'themes' is set to 'false' the 
		// 'themesPath' option is ignored.
		themesPath: '/reveal-js/css/theme/',

		// Specifies if the transitions menu panel will be shown.
		// Set to 'true' to show the transitions menu panel with
		// the default transitions list. Alternatively, provide an
		// array to specify the transitions to make available in
		// the transitions panel, for example...
		// ['None', 'Fade', 'Slide']
		transitions: true,

		// Adds a menu button to the slides to open the menu panel.
		// Set to 'false' to hide the button.
		openButton: true,

		// If 'true' allows the slide number in the presentation to
		// open the menu panel. The reveal.js slideNumber option must 
		// be displayed for this to take effect
		openSlideNumber: false,

		// If true allows the user to open and navigate the menu using
		// the keyboard. Standard keyboard interaction with reveal
		// will be disabled while the menu is open.
		keyboard: true,

		// Normally the menu will close on user actions such as
		// selecting a menu item, or clicking the presentation area.
		// If 'true', the sticky option will leave the menu open
		// until it is explicitly closed, that is, using the close
		// button or pressing the ESC or m key (when the keyboard 
		// interaction option is enabled).
		sticky: false,

		// If 'true' standard menu items will be automatically opened
		// when navigating using the keyboard. Note: this only takes 
		// effect when both the 'keyboard' and 'sticky' options are enabled.
		autoOpen: true,

		// If 'true' the menu will not be created until it is explicitly
		// requested by calling RevealMenu.init(). Note this will delay
		// the creation of all menu panels, including custom panels, and
		// the menu button.
		delayInit: false,

		// If 'true' the menu will be shown when the menu is initialised.
		openOnInit: false,

		// By default the menu will load it's own font-awesome library
		// icons. If your presentation needs to load a different
		// font-awesome library the 'loadIcons' option can be set to false
		// and the menu will not attempt to load the font-awesome library.
        loadIcons: true,
        
        custom: [
			{ title: 'Links', icon: '<i class="fa fa-external-link-alt">', src: 'links.html' },
			{ title: 'About', icon: '<i class="fa fa-info">', content: '<p>This slidedeck is created with reveal.js</p>' }
		]
	},

customcontrols: { 
		slideNumberCSS : 'position: fixed; display: block; right: 90px; top: auto; left: auto; width: 50px; bottom: 30px; z-index: 31; font-family: Helvetica, sans-serif; font-size:  12px; line-height: 1; padding: 5px; text-align: center; border-radius: 10px; background-color: rgba(128,128,128,.5);', 
		controls: [ 
			{ icon: '<i class="fa fa-caret-left"></i>', 
			  css: 'position: fixed; right: 60px; bottom: 30px; z-index: 30; font-size: 24px;', 
			  action: 'Reveal.prev(); return false;' 
			}, 
			{ icon: '<i class="fa fa-caret-right"></i>', 
			  css: 'position: fixed; right: 30px; bottom: 30px; z-index: 30; font-size: 24px;', 
			  action: 'Reveal.next(); return false;' 
			}
		] 
	},
// Optional reveal.js plugins
dependencies: [
{ src: '/reveal-js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
{ src: '/reveal-js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
{ src: '/reveal-js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
{ src: '/reveal-js/plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
{ src: '/reveal-js/plugin/zoom-js/zoom.js', async: true },
{ src: '/reveal-js/plugin/notes/notes.js', async: true },
{ src: '/reveal-js/plugin/customcontrols/customcontrols.js', async: true },
{ src: '/reveal-js/plugin/chalkboard/chalkboard.js', async: true },
{ src: '/reveal-js/plugin/fullscreen/fullscreen.js', async: true },
{ src: '/reveal-js/plugin/chart/Chart.min.js', async: true },
{ src: '/reveal-js/plugin/anything/anything.js', async: true },
{ src: '/reveal-js/plugin/menu/menu.js', async: true},
{ src: '/math-katex/math-katex.js', async: true },
]
});

</script>

</body>
</html>
